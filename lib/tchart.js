// Generated by CoffeeScript 1.10.0
(function() {
  var SvgPath, TimeLine, TimingChart, isNumeric,
    hasProp = {}.hasOwnProperty;

  SvgPath = (function() {
    function SvgPath(style) {
      this.segments = [];
      this.style = style;
    }

    SvgPath.prototype.draw = function(x1, y1, x2, y2) {
      return this.segments.push([x1, y1, x2, y2]);
    };

    SvgPath.prototype.connectSegments = function() {
      var j, l, len, len1, len2, len3, n, o, ref, ref1, ref2, ref3, results, s1, s2;
      ref = this.segments;
      for (j = 0, len = ref.length; j < len; j++) {
        s1 = ref[j];
        s1[4] = null;
        s1[5] = null;
        ref1 = this.segments;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          s2 = ref1[l];
          if (s1[2] === s2[0] && s1[3] === s2[1]) {
            s1[4] = s2;
            s2[5] = s1;
            break;
          }
        }
      }
      ref2 = this.segments;
      results = [];
      for (n = 0, len2 = ref2.length; n < len2; n++) {
        s1 = ref2[n];
        if (s1[4] && !s1[4][4]) {
          ref3 = this.segiments;
          for (o = 0, len3 = ref3.length; o < len3; o++) {
            s2 = ref3[o];
            if (s1[2] === s2[0] && s1[3] === s2[1] && s2[4] && !s2[5]) {
              s1[4][5] = null;
              s1[4] = s2;
              s2[5] = s1;
              break;
            }
          }
        }
        if (s1[5] && !s1[5][5]) {
          results.push((function() {
            var len4, p, ref4, results1;
            ref4 = this.segiments;
            results1 = [];
            for (p = 0, len4 = ref4.length; p < len4; p++) {
              s2 = ref4[p];
              if (s2[2] === s1[0] && s2[3] === s1[1] && s2[5] && !s2[4]) {
                s1[5][4] = null;
                s1[5] = s2;
                s2[4] = s1;
                break;
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    SvgPath.prototype.svg = function() {
      var cx, cy, j, len, path, ref, s, s1;
      path = [];
      ref = this.segments;
      for (j = 0, len = ref.length; j < len; j++) {
        s1 = ref[j];
        if (s1[5]) {
          continue;
        }
        s = s1;
        cx = s[0];
        cy = s[1];
        path.push("M" + cx + "," + cy);
        while (s) {
          if (cx === s[2] && cy === s[3]) {

          } else if (cx === s[2]) {
            if (path[path.length - 1][0] === 'V') {
              path[path.length - 1] = "V" + s[3];
            } else {
              path.push("V" + s[3]);
            }
          } else if (cy === s[3]) {
            if (path[path.length - 1][0] === 'H') {
              path[path.length - 1] = "H" + s[2];
            } else {
              path.push("H" + s[2]);
            }
          } else {
            path.push("L" + s[2] + "," + s[3]);
          }
          cx = s[2];
          cy = s[3];
          s = s[4];
        }
      }
      return "<path " + this.style + " d=\"" + (path.join('')) + "\" />\n";
    };

    return SvgPath;

  })();

  TimeLine = (function() {
    TimeLine.transitions = ['          ', '  - 1 4 14', '  2 ~ / ~/', '  3 ` _ _`', '  23`~/_= ', '  23`~/_=/', '  23`~/_=`', '  23`~/_X ', '  23`~/_=X'];

    TimeLine.transitionLines = {
      ' ': [],
      '~': [[1, 1]],
      '_': [[0, 0]],
      '=': [[1, 1], [0, 0]],
      'X': [[1, 0], [0, 1]],
      '`': [[1, 0]],
      '/': [[0, 1]],
      '1': [[1, 0.5]],
      '2': [[0.5, 1]],
      '3': [[0.5, 0]],
      '4': [[0, 0.5]],
      '-': [[0.5, 0.5]]
    };

    TimeLine.stateLines = [[], [0.5], [1], [0], [0, 1]];

    TimeLine.codes = ':-~_=/\\X*';

    function TimeLine(config, y) {
      this.config = config;
      this.x = config.w_caption;
      this.y = y;
      this.path = new SvgPath(config.signal_style);
      this.current = 0;
      this.crosses = [];
      this.strings = [];
      this.guides = [];
      this.highlights = [];
    }

    TimeLine.prototype.ys = function(s) {
      return this.y + (1 - s) * this.config.h_line;
    };

    TimeLine.prototype.y0 = function() {
      return this.ys(0);
    };

    TimeLine.prototype.y1 = function() {
      return this.ys(1);
    };

    TimeLine.prototype.yz = function() {
      return this.ys(0.5);
    };

    TimeLine.prototype.xh = function() {
      return this.x + this.config.w_transient / 2.0;
    };

    TimeLine.prototype.xt = function() {
      return this.x + this.config.w_transient;
    };

    TimeLine.prototype.xr = function() {
      return this.x + this.config.w_transient + this.config.w_hold;
    };

    TimeLine.prototype.parse = function(line) {
      var maches, matches;
      while (line.length > 0) {
        if (maches = /^\s+/.exec(line)) {

        } else if (maches = /^\|/.exec(line)) {
          this.guides.push([this.xh(), this.config.guide_style]);
        } else if (maches = /^\[/.exec(line)) {
          if (this.highlights.length === 0 || Array.isArray(this.highlights[this.highlights.length - 1])) {
            this.highlights.push(this.xh());
          }
        } else if (maches = /^\]/.exec(line)) {
          if (this.highlights.length > 0 && !Array.isArray(this.highlights[this.highlights.length - 1])) {
            this.highlights[this.highlights.length - 1] = [this.highlights[this.highlights.length - 1], this.xh(), this.config.highlight_style];
          }
        } else if (matches = /^([:\-~_=\/\\X*])/.exec(line)) {
          this.addState(matches[1]);
        } else if (matches = /^"(([^"]|"")*)"/.exec(line)) {
          this.addString(matches[1].replace(/""/g, '"').replace(/\ /g, '&nbsp;'));
        } else if (matches = /^'(([^']|'')*)'/.exec(line)) {
          this.addString(matches[1].replace(/''/g, "'").replace(/\ /g, '&nbsp;'));
        } else if (matches = /([^:\-~_=\/\\X*\|\]\[]+)/.exec(line)) {
          this.addString(matches[1]);
        }
        line = line.substr(matches[0].length, line.length - matches[0].length);
      }
      return this.processStrings() + this.path.svg();
    };

    TimeLine.prototype.addState = function(c) {
      var crosses, s;
      s = TimeLine.codes.indexOf(c);
      crosses = this.drawTransition(s);
      if (s > 4) {
        s = 4;
      }
      this.drawState(s);
      if (crosses !== '') {
        this.crosses.push([this.x, crosses]);
      }
      if ((this.current === 0 && s !== 0) || (this.current !== 0 && s === 0) || (this.crosses.length === 0 && s === 0)) {
        this.crosses.push([this.x, '|']);
      }
      this.current = s;
      return this.x = this.xr();
    };

    TimeLine.prototype.addString = function(s) {
      return this.strings.push([this.crosses.length, s.replace(/^\s+|\s+$/g, '')]);
    };

    TimeLine.prototype.drawTransition = function(s) {
      var crosses, i, j, ref, transitions;
      crosses = '';
      transitions = TimeLine.transitions[s].substr(2 * this.current, 2);
      for (i = j = 0, ref = transitions.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        crosses += this.drawTransitionSub(transitions[i]);
      }
      return crosses;
    };

    TimeLine.prototype.drawTransitionSub = function(c) {
      var crosses, j, len, line, ref;
      crosses = '';
      ref = TimeLine.transitionLines[c];
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        this.path.draw(this.x, this.ys(line[0]), this.xt(), this.ys(line[1]));
        if (line[0] !== line[1]) {
          crosses += c;
        }
      }
      return crosses;
    };

    TimeLine.prototype.drawState = function(s) {
      var j, len, line, ref, results;
      ref = TimeLine.stateLines[s];
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        results.push(this.path.draw(this.xt(), this.ys(line), this.xr(), this.ys(line)));
      }
      return results;
    };

    TimeLine.prototype.processStrings = function() {
      var anchor, j, len, path, ref, sanitized, string, svg, x, x1, x1h, x1r, x1t, x2, x2h, x2r, x2t, y0, y1, yz;
      svg = [];
      this.crosses.push([this.x, '|']);
      ref = this.strings;
      for (j = 0, len = ref.length; j < len; j++) {
        string = ref[j];
        y0 = this.ys(0);
        y1 = this.ys(1);
        yz = this.ys(0.5);
        x1 = this.crosses[string[0] - 1][0];
        x1t = x1 + this.config.w_transient;
        x1h = x1 + this.config.w_transient / 2.0;
        x1r = x1t + this.config.w_hold;
        x2 = this.crosses[string[0]][0];
        x2t = x2 + this.config.w_transient;
        x2h = x2 + this.config.w_transient / 2.0;
        x2r = x2t + this.config.w_hold;
        if (string[1] === '?') {
          path = ["M" + x1t + "," + y1 + "H" + x2];
          path.push((function() {
            switch (this.crosses[string[0]][1]) {
              case '|':
                return "";
              case 'XX':
                return "L" + x2h + "," + yz;
              case '/':
                return "H" + x2t;
              case '`':
                return "L" + x2t + "," + y0;
              case '23':
                return "H" + x2t + "L" + x2 + "," + yz + "L" + x2t + "," + y0;
              case '14':
                return "L" + x2t + "," + yz;
              case '1':
                return "L" + x2t + "," + yz + "V" + y0;
              case '2':
                return "H" + x2t + "L" + x2 + "," + yz;
              case '3':
                return "V" + yz + "L" + x2t + "," + y0;
              case '4':
                return "H" + x2t + "V" + yz;
            }
          }).call(this));
          path.push("L" + x2 + "," + y0 + "H" + x1t);
          path.push((function() {
            switch (this.crosses[string[0] - 1][1]) {
              case '|':
                return "";
              case 'XX':
                return "L" + x1h + "," + yz;
              case '/':
                return "H" + x1;
              case '`':
                return "L" + x1 + "," + y1;
              case '23':
                return "L" + x1 + "," + yz;
              case '14':
                return "H" + x1 + "L" + x1t + "," + yz + "L" + x1 + "," + y1;
              case '1':
                return "V" + yz + "L" + x1 + "," + y1;
              case '2':
                return "H" + x1 + "V" + yz;
              case '3':
                return "L" + x1 + "," + yz + "V{y1}";
              case '4':
                return "H" + x1 + "L" + xt + "," + yz;
            }
          }).call(this));
          path.push("Z");
          svg.push("\n<path stroke=\"none\" d=\"" + (path.join('')) + "\" " + this.config.notcare_style + "/>");
        }
        sanitized = string[1].replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        if (string[1].substr(0, 3) === '_<_') {
          x = x1t;
          anchor = 'start';
          sanitized = sanitized.substring(6);
        } else if (string[1].substr(0, 3) === '_>_') {
          x = x2;
          anchor = 'end';
          sanitized = sanitized.substring(6);
        } else {
          x = (x1h + x2h) / 2.0;
          anchor = 'middle';
        }
        svg.push(("<text x=\"" + x + "\" y=\"" + (this.ys(0) - 1.5) + "\" text-anchor=\"" + anchor + "\" ") + ("font-size=\"" + this.config.h_line + "\" " + this.config.signal_font + ">" + sanitized + "</text>\n"));
      }
      return svg.join("");
    };

    return TimeLine;

  })();

  isNumeric = function(obj) {
    var type;
    type = typeof obj;
    return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
  };

  TimingChart = (function() {
    TimingChart.config = {
      scale: 1.0,
      margin: 10,
      w_caption: 40,
      w_hold: 10,
      w_transient: 2,
      h_line: 10,
      h_space: 10,
      signal_style: 'stroke-linecap="round" stroke-width="0.6" stroke="black" fill="none"',
      guide_style: 'stroke-width="0.6" stroke="red"',
      highlight_style: 'stroke="none" fill="#ff8"',
      notcare_style: 'fill="#ccc"',
      rotate: 0,
      caption_font: 'fill="black" font-family="Helvetica"',
      signal_font: 'fill="black" font-family="Helvetica"',
      grid: 'off',
      grid_style: 'stroke-width="0.3" stroke="#ccc"',
      grid_step: 1,
      grid_offset: 0
    };

    TimingChart.format = function(source, config) {
      if (config == null) {
        config = {};
      }
      return (new TimingChart(config)).parse(source);
    };

    function TimingChart(config) {
      if (config == null) {
        config = {};
      }
      this.config = {};
      this.setConfig(TimingChart.config);
      this.setConfig(config);
    }

    TimingChart.prototype.setConfig = function(config) {
      var k, results, v;
      results = [];
      for (k in config) {
        if (!hasProp.call(config, k)) continue;
        v = config[k];
        results.push(this.config[k] = v);
      }
      return results;
    };

    TimingChart.prototype.setupGrid = function() {
      return this.grid = [this.config.w_caption + this.config.w_transient / 2.0, this.config.w_hold + this.config.w_transient];
    };

    TimingChart.prototype.parse = function(source) {
      var j, len, line, ref;
      this.svg = [];
      this.guides = [];
      this.highlights = [];
      this.y = -1;
      this.x_max = this.config.w_caption;
      source = source.replace(/^\n+/, '');
      source = source.replace(/\n+$/, '');
      if (this.config.grid === 'on') {
        this.setupGrid();
      }
      ref = source.split("\n");
      for (j = 0, len = ref.length; j < len; j++) {
        line = ref[j];
        this.parseLine(line);
      }
      this.processGrid();
      this.processGuides();
      this.processHighlights();
      return this.formatSVG(source);
    };

    TimingChart.prototype.formatSVG = function(source) {
      var h, m, w;
      m = this.config.margin;
      w = (this.x_max + 2 * m) * this.config.scale * 1.3;
      h = (this.y + 2 * m) * this.config.scale * 1.3;
      this.width = w;
      this.height = h;
      return this.svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  width=\"" + w + "px\" height=\"" + h + "px\" viewBox=\"" + (-m) + " " + (-m) + " " + (this.x_max + 2 * m) + " " + (this.y + 2 * m) + "\" version=\"1.1\">\n<![CDATA[\n" + (source.replace(/\]\]\>/g, ']]&gt;')) + "\n]]>\n<g>\n" + (this.svg.join("\n")) + "\n</g>\n</svg>";
    };

    TimingChart.prototype.processConfiguration = function(name, value) {
      if (name === 'grid') {
        if (value === 'on') {
          this.setupGrid();
        } else if (value === 'off') {
          this.grid = null;
        } else {
          throw new SyntaxError("Illegal Line: " + line);
        }
      } else if (isNumeric(this.config[name])) {
        this.config[name] = Number(value);
      } else {
        this.config[name] = value;
      }
    };

    TimingChart.prototype.parseLine = function(line) {
      var matches;
      if (line[0] === '#') {
        return;
      }
      if (line[0] === '@') {
        if (!(matches = /^@([^\s]+)\s+([^\s].*?)\s*$/.exec(line))) {
          throw new SyntaxError("Illegal Line: " + line);
        }
        this.processConfiguration(matches[1], matches[2]);
        return;
      }
      if (line[0] === '%') {
        if (!(matches = /^%(-?[\d\.]+)\s+(-?[\d\.]+)\s+?(.*)$/.exec(line))) {
          throw new SyntaxError("Illegal Line: " + line);
        }
        this.svg.push(("<text x=\"" + matches[1] + "\" y=\"" + matches[2] + "\" text-anchor=\"middle\" ") + ("font-size=\"" + this.config.h_line + "\" " + this.config.signal_font + ">" + matches[3] + "</text>"));
        return;
      }
      if (this.y < 0) {
        this.y = 0;
      } else {
        this.y += this.config.h_space;
      }
      line = line.replace(/\s*$/, '');
      if (line === '') {
        return;
      }
      if (matches = /^"((?:[^"]|"")+)"\s+([^\s].*)$/.exec(line)) {
        this.formatCaption(matches[1].replace(/""/, '"'));
        this.formatTimeline(matches[2]);
      } else if (matches = /^'((?:[^']|'')+)'\s+([^\s].*)$/.exec(line)) {
        this.formatCaption(matches[1].replace(/''/, "'"));
        this.formatTimeline(matches[2]);
      } else if (matches = /^([^\s]+)\s+([^\s].*)$/.exec(line)) {
        this.formatCaption(matches[1]);
        this.formatTimeline(matches[2]);
      } else {
        throw new SyntaxError("Illegal Line: " + line);
      }
      return this.y += this.config.h_line;
    };

    TimingChart.prototype.formatCaption = function(caption) {
      var sanitized;
      sanitized = caption.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      return this.svg.push(("<text x=\"" + (this.config.w_caption - 5) + "\" y=\"" + (this.y + this.config.h_line - 1.5) + "\" text-anchor=\"end\" ") + ("font-size=\"" + this.config.h_line + "\" " + this.config.caption_font + ">" + sanitized + "</text>"));
    };

    TimingChart.prototype.formatTimeline = function(line) {
      var g, h, j, l, len, len1, ref, ref1, results, tline;
      tline = new TimeLine(this.config, this.y);
      this.svg.push(tline.parse(line));
      if (tline.x > this.x_max) {
        this.x_max = tline.x;
      }
      ref = tline.guides;
      for (j = 0, len = ref.length; j < len; j++) {
        g = ref[j];
        this.guides.push(g);
      }
      ref1 = tline.highlights;
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        h = ref1[l];
        results.push(this.highlights.push(h));
      }
      return results;
    };

    TimingChart.prototype.processGrid = function() {
      var b, results, t, x;
      if (!this.grid) {
        return;
      }
      t = -this.config.margin / 2.0;
      b = this.y + this.config.margin / 2.0;
      x = this.grid[0] + this.grid[1] * this.config.grid_offset;
      results = [];
      while (x < this.x_max) {
        this.svg.unshift("<path d=\"M" + x + "," + t + "V" + b + "\" " + this.config.grid_style + " />");
        results.push(x += this.grid[1] * this.config.grid_step);
      }
      return results;
    };

    TimingChart.prototype.processGuides = function() {
      var b, g, j, len, ref, results, t;
      t = -this.config.margin / 2.0;
      b = this.y + this.config.margin / 2.0;
      ref = this.guides;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        g = ref[j];
        results.push(this.svg.push("<path d=\"M" + g[0] + "," + t + "V" + b + "\" " + g[1] + " />"));
      }
      return results;
    };

    TimingChart.prototype.processHighlights = function() {
      var b, h, j, len, ref, results, t;
      t = -this.config.margin / 2.0;
      b = this.y + this.config.margin / 2.0;
      ref = this.highlights;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        h = ref[j];
        if (Array.isArray(h)) {
          results.push(this.svg.unshift("<path d=\"M" + h[0] + "," + t + "V" + b + "H" + h[1] + "V" + t + "Z\" " + h[2] + " />"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return TimingChart;

  })();

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = TimingChart;
  } else {
    this.TimingChart = TimingChart;
  }

}).call(this);

//# sourceMappingURL=tchart.js.map
